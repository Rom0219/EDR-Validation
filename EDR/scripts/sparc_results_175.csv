import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pathlib import Path
from scipy.optimize import least_squares
import warnings
import sys

# Configurar la codificación de la consola para evitar errores de caracteres
sys.stdout.reconfigure(encoding='utf-8')

# Ignorar warnings de log(0) temporalmente
warnings.filterwarnings("ignore", category=RuntimeWarning) 

# --- CONFIGURACIÓN DE RUTAS ---

# Directorio base para los archivos de resultados y gráficos individuales
# ¡ESTA ES LA RUTA CORRECTA QUE QUEREMOS USAR!
NEW_BASE_DIR = Path("EDR/data/sparc/datafiles175")
NEW_BASE_DIR.mkdir(parents=True, exist_ok=True) # Asegura que el directorio exista

# Archivo de datos SPARC (Tabla 2) - Se asume que está en la ruta raíz del proyecto
DATA_FILE = Path("EDR/data/sparc/SPARC_Lelli2016_Table2.txt")
# Directorio de salida para los gráficos individuales (dentro de datafiles175)
OUT_DIR = NEW_BASE_DIR 
# Archivo de salida para los parámetros ajustados de las 175 galaxias
RESULTS_CSV = OUT_DIR / "sparc_results_175.csv" 

# Flag para la generación de gráficos individuales (IMPORTANTE: MANTENER EN True)
DO_PLOTTING = True 

# --- MODELO EDR (Exponential Density Profile + Radial Acceleration) ---

def V_disk(R_data, Yd):
    """Componente de velocidad del disco, escalada por la relación Masa/Luminosidad (Yd)."""
    # Vdisk es la velocidad del disco si Yd = 1.0 (en km/s)
    return np.sqrt(Yd) * R_data['Vdisk']

def V_bulge(R_data, Yb):
    """Componente de velocidad del Bulge, escalada por la relación Masa/Luminosidad (Yb)."""
    # Vbul es la velocidad del bulge si Yb = 1.0 (en km/s)
    return np.sqrt(Yb) * R_data['Vbul']

def V_gas(R_data):
    """Componente de velocidad del gas (H I)."""
    # Vgas ya está en km/s
    return R_data['Vgas']

def V_baryons_sq(R_data, Yd, Yb):
    """Velocidad circular cuadrática de las componentes bariónicas."""
    return V_gas(R_data)**2 + V_disk(R_data, Yd)**2 + V_bulge(R_data, Yb)**2

def V_edr_sq(R_data, V_max_sq, R_scale):
    """Velocidad circular cuadrática del perfil de Materia Oscura (Halo EDR paramétrico)."""
    R = R_data['R']
    R_scale = np.clip(R_scale, 0.1, R_scale) # Asegura R_scale > 0
    x = R / R_scale
    # Fórmula del perfil de halo exponencial: V_DM^2 = V_max^2 * (1 - (1 + R/R_scale) * exp(-R/R_scale))
    V_sq = V_max_sq * (1.0 - (1.0 + x) * np.exp(-x))
    V_sq[V_sq < 0] = 0 # V_DM^2 no puede ser negativo
    return V_sq


def V_total(R_data, Yd, Yb, V_max_sq, R_scale):
    """Velocidad circular total cuadrática: V_tot^2 = V_bar^2 + V_DM^2"""
    V_sq = V_baryons_sq(R_data, Yd, Yb) + V_edr_sq(R_data, V_max_sq, R_scale)
    V_sq[V_sq < 0] = 0
    return np.sqrt(V_sq)

def residuals(params, R_data, Vobs, e_Vobs):
    """Vector de residuales para la minimización (chi-cuadrado)."""
    # Parámetros a ajustar: [Yd, Yb, V_max_sq, R_scale, sigma_extra]
    Yd, Yb, V_max_sq, R_scale, sigma_extra = params 
    
    # Restricciones de parámetros (positividad y límites físicos)
    if Yd < 0.01 or Yb < 0.0 or V_max_sq < 0.01 or R_scale < 0.1 or sigma_extra < 0:
        # Devuelve un array de infinito si los límites se violan fuertemente
        return np.inf * np.ones_like(Vobs)
        
    Vmodel = V_total(R_data, Yd, Yb, V_max_sq, R_scale)
    # Incertidumbre total en cuadratura: error de medición + error sistemático extra
    sigma_tot_sq = e_Vobs**2 + sigma_extra**2
    
    # Residual normalizado: (Observado - Modelo) / Incertidumbre total
    return (Vobs - Vmodel) / np.sqrt(sigma_tot_sq)

# --- FUNCIÓN DE PLOTEO ---

def plot_fit(df_rc, R_data, popt, chi2_red):
    """Genera y guarda el gráfico de ajuste de la curva de rotación."""
    
    galaxy_name = df_rc['ID'].iloc[0]
    # Crear un grid de radio más fino para una curva suave
    R_grid = np.linspace(R_data['R'].min(), R_data['R'].max(), 100)
    
    # Interpolación para obtener los valores bariónicos en el grid (necesario para componentes suaves)
    R_data_grid = {'Vdisk': np.interp(R_grid, R_data['R'], R_data['Vdisk']),
                   'Vbul': np.interp(R_grid, R_data['R'], R_data['Vbul']),
                   'Vgas': np.interp(R_grid, R_data['R'], R_data['Vgas']),
                   'R': R_grid}
    
    # Parámetros ajustados
    Yd, Yb, V_max_sq, R_scale, sigma_extra = popt
    
    # Componentes modeladas
    Vbar_sq = V_baryons_sq(R_data_grid, Yd, Yb)
    Vdm_sq = V_edr_sq(R_data_grid, V_max_sq, R_scale)
    Vtot_model = V_total(R_data_grid, Yd, Yb, V_max_sq, R_scale)
    
    # Gráfico
    plt.figure(figsize=(8, 6))
    
    # Datos observados
    plt.errorbar(df_rc['R'], df_rc['Vobs'], yerr=df_rc['e_Vobs'], 
                 fmt='o', color='black', ecolor='gray', capsize=2, label='Observado')

    # Curva total modelada
    plt.plot(R_grid, Vtot_model, color='red', linewidth=3, label='Modelo EDR Total')
    
    # Componentes individuales
    plt.plot(R_grid, np.sqrt(Vbar_sq), linestyle='--', color='blue', label='Bariónica Total')
    plt.plot(R_grid, np.sqrt(Vdm_sq), linestyle=':', color='purple', label='Materia Oscura EDR')
    
    plt.xlabel('Radio (kpc)')
    plt.ylabel('Velocidad (km/s)')
    plt.title(f'Ajuste Curva de Rotación EDR: {galaxy_name}')
    
    # Mostrar parámetros en el gráfico
    text_info = (
        f'$Y_d = {Yd:.2f}$\n'
        f'$Y_b = {Yb:.2f}$\n'
        f'$A = {V_max_sq:.0f}$ (km/s)$^2$\n'
        f'$R_0 = {R_scale:.2f}$ kpc\n'
        f'$\\chi^2_\\text{{red}} = {chi2_red:.2f}$'
    )
    plt.text(0.95, 0.25, text_info, transform=plt.gca().transAxes, 
             fontsize=10, verticalalignment='top', horizontalalignment='right',
             bbox=dict(boxstyle="round,pad=0.5", fc="white", alpha=0.8))
             
    plt.legend(loc='upper left')
    plt.grid(True, linestyle=':', alpha=0.6)

    # Guardar gráfico en el directorio OUT_DIR
    plot_path = OUT_DIR / f"{galaxy_name}_fit.png"
    plt.savefig(plot_path, dpi=100, bbox_inches='tight') 
    plt.close()

# --- FUNCIÓN PRINCIPAL DE AJUSTE ---

def fit_galaxy_curve(df_rc, do_plotting):
    """Ajusta la curva de rotación para una sola galaxia y plotea si se requiere."""
    
    galaxy_name = df_rc['ID'].iloc[0]
    R = df_rc['R'].values
    Vobs = df_rc['Vobs'].values
    e_Vobs = df_rc['e_Vobs'].values
    
    R_data = {
        'Vdisk': df_rc['Vdisk'].values, 'Vbul': df_rc['Vbul'].values, 
        'Vgas': df_rc['Vgas'].values, 'R': R
    }
    
    # Valores Iniciales (Initial Guess): [Yd, Yb, V_max_sq, R_scale, sigma_extra]
    Vobs_max = np.nanmax(Vobs) if Vobs.size > 0 else 100.0
    p0 = [1.0, 0.01, Vobs_max**2 * 4.0, 10.0, 1.0] 
    
    # Límites de los Parámetros
    bounds = (
        [0.01, 0.0, 0.01, 0.1, 0.0],  # Límite inferior
        [5.0, 5.0, 500000.0, 100.0, 5.0]  # Límite superior
    )
    
    try:
        # Usar el método de mínimos cuadrados no lineal
        result = least_squares(
            residuals, p0, args=(R_data, Vobs, e_Vobs), 
            bounds=bounds, method='trf', max_nfev=2000 # 'trf' es robusto para límites
        )
        popt = result.x
        
        dof = len(Vobs) - len(popt) # Grados de libertad
        chi2 = np.sum(residuals(popt, R_data, Vobs, e_Vobs)**2)
        chi2_red = chi2 / dof if dof > 0 else np.nan
        
        fit_results = {
            'Galaxy': galaxy_name, 'Yd': popt[0], 'Yb': popt[1], 
            'A': popt[2], 'R0': popt[3], 'sigma_extra': popt[4], 
            'chi2_red': chi2_red
        }
        
        if do_plotting:
            plot_fit(df_rc, R_data, popt, chi2_red)
        
        return fit_results

    except Exception as e:
        # En caso de que el ajuste falle por cualquier razón (ej. convergencia)
        print(f"ERROR: Ajuste fallido para {galaxy_name}. Detalle: {e}")
        return {'Galaxy': galaxy_name, 'Yd': np.nan, 'Yb': np.nan, 'A': np.nan, 'R0': np.nan, 'sigma_extra': np.nan, 'chi2_red': np.nan}


# --- CARGA Y PREPARACIÓN DE DATOS ---

def load_sparc_data(filepath):
    """Carga los datos de la Tabla 2 de SPARC y devuelve el DataFrame completo."""
    try:
        # Definición de nombres de columnas
        col_names = ['ID', 'D', 'R', 'Vobs', 'e_Vobs', 'Vgas', 'Vdisk', 'Vbul', 'SBdisk', 'SBbul']
        
        # Lectura de archivos de ancho fijo
        df = pd.read_fwf(
            filepath,
            colspecs=[
                (0, 11), (12, 18), (19, 25), (26, 32), (33, 38), 
                (39, 45), (46, 52), (53, 59), (60, 67), (68, 76)
            ],
            header=None,
            names=col_names,
            skiprows=42, # Saltar el encabezado y la descripción
            dtype={'ID': str} 
        )
        
        df['ID'] = df['ID'].str.strip()
        numeric_cols = ['D', 'R', 'Vobs', 'e_Vobs', 'Vgas', 'Vdisk', 'Vbul', 'SBdisk', 'SBbul']
        for col in numeric_cols:
            df[col] = pd.to_numeric(df[col], errors='coerce')
            
        return df

    except FileNotFoundError:
        print(f"ERROR: Archivo de datos SPARC no encontrado en: {filepath}")
        return None
    except Exception as e:
        print(f"ERROR al parsear {filepath}. Revisar el formato de ancho fijo. Detalle: {e}")
        return None

# --- EJECUCIÓN DEL FLUJO ---

if __name__ == '__main__':
    
    df_sparc_full = load_sparc_data(DATA_FILE) 
    
    if df_sparc_full is None or df_sparc_full.empty:
        print("Fallo al cargar los datos. No se puede proceder con el ajuste.")
        exit()

    # Obtener lista de galaxias únicas
    unique_galaxies = df_sparc_full['ID'].dropna().unique()
    
    print(f"--- INICIANDO AJUSTE Y PLOTEO EDR: MUESTRA COMPLETA SPARC (N={len(unique_galaxies)}) ---")
    print(f"RESULTADOS Y GRÁFICOS SE GUARDARÁN EN: {NEW_BASE_DIR}")
        
    all_results = []
    success_count = 0
    
    for i, galaxy in enumerate(unique_galaxies):
        
        # Imprimir progreso cada 25 galaxias
        if (i + 1) % 25 == 0 or i == 0 or i == len(unique_galaxies) - 1:
            print(f"Progreso: Procesando galaxia {i+1}/{len(unique_galaxies)}: {galaxy}...")

        df_rc = df_sparc_full[df_sparc_full['ID'] == galaxy].copy()
        
        # Pre-procesamiento: rellenar Bulge (Vbul) con 0.0 si es NaN (asumiendo disco puro)
        df_rc['Vbul'] = df_rc['Vbul'].fillna(0.0) 
        # Filtrar puntos con NaNs cruciales o radio cero
        df_rc = df_rc.dropna(subset=['R', 'Vobs', 'e_Vobs', 'Vgas', 'Vdisk'])
        df_rc = df_rc[df_rc['R'] > 0]
        
        if df_rc.empty or len(df_rc) < 5:
            print(f"AVISO: Galaxia {galaxy} omitida, no tiene suficientes puntos de datos válidos (puntos: {len(df_rc)}).")
            all_results.append({'Galaxy': galaxy, 'Yd': np.nan, 'Yb': np.nan, 'A': np.nan, 'R0': np.nan, 'sigma_extra': np.nan, 'chi2_red': np.nan})
            continue
            
        fit_res = fit_galaxy_curve(df_rc, do_plotting=DO_PLOTTING)
        all_results.append(fit_res) 
        
        if not np.isnan(fit_res['chi2_red']):
            success_count += 1
        
    print(f"\n--- AJUSTE DE CURVAS FINALIZADO ({success_count}/{len(unique_galaxies)} galaxias ajustadas y ploteadas) ---")

    # Guardar todos los resultados de los parámetros ajustados
    df_results = pd.DataFrame(all_results)
    df_results.to_csv(RESULTS_CSV, index=False)
    
    print(f"RESULTADOS GLOBALES GUARDADOS EN: {RESULTS_CSV}")
    print(f"GRÁFICOS INDIVIDUALES GUARDADOS EN: {OUT_DIR}")
